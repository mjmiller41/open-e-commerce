
-- Create reviews table
-- Create reviews table
-- Note: Referencing public.profiles allows PostgREST to auto-detect the relationship for joins.
CREATE TABLE IF NOT EXISTS public.reviews (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    product_id bigint NOT NULL REFERENCES public.products(id) ON DELETE CASCADE,
    order_id bigint NOT NULL REFERENCES public.orders(id) ON DELETE CASCADE,
    rating integer NOT NULL CHECK (rating >= 1 AND rating <= 5),
    comment text,
    status text NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')),
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Ensure status column exists (in case table already existed)
DO $$ 
BEGIN 
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'reviews' AND column_name = 'status') THEN 
        ALTER TABLE public.reviews ADD COLUMN status text NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')); 
    END IF; 
END $$;

-- Ensure Foreign Key points to public.profiles (for PostgREST relationship detection) instead of auth.users
DO $$
DECLARE
    fk_name text;
BEGIN
    -- Find existing FK on user_id
    SELECT constraint_name INTO fk_name
    FROM information_schema.key_column_usage
    WHERE table_schema = 'public' AND table_name = 'reviews' AND column_name = 'user_id'
    LIMIT 1;

    -- If FK references auth.users (which we can't easily check via info_schema due to permissions sometimes, but we can check constraint name usually)
    -- Or we can just drop and recreate to be safe if we want to enforce public.profiles.
    -- Let's just try to drop and add the correct one.
    
    IF fk_name IS NOT NULL THEN
        EXECUTE 'ALTER TABLE public.reviews DROP CONSTRAINT ' || fk_name;
    END IF;

    -- Add the correct constraint
    ALTER TABLE public.reviews
    ADD CONSTRAINT reviews_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE;
END $$;

-- Enable RLS
ALTER TABLE public.reviews ENABLE ROW LEVEL SECURITY;

-- Policies

-- 1. Public can read approved reviews
DROP POLICY IF EXISTS "Public can view approved reviews" ON public.reviews;
CREATE POLICY "Public can view approved reviews" ON public.reviews
    FOR SELECT
    USING (status = 'approved');

-- 2. Users can see their own reviews (even if pending/rejected)
DROP POLICY IF EXISTS "Users can view their own reviews" ON public.reviews;
CREATE POLICY "Users can view their own reviews" ON public.reviews
    FOR SELECT
    USING (auth.uid() = user_id);

-- 3. Admins can view all reviews
DROP POLICY IF EXISTS "Admins can view all reviews" ON public.reviews;
CREATE POLICY "Admins can view all reviews" ON public.reviews
    FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.profiles
            WHERE profiles.id = auth.uid()
            AND profiles.role = 'admin'
        )
    );

-- 4. Authenticated users can insert reviews (must have logic to check order, but RLS just checks auth)
DROP POLICY IF EXISTS "Authenticated users can insert reviews" ON public.reviews;
CREATE POLICY "Authenticated users can insert reviews" ON public.reviews
    FOR INSERT
    WITH CHECK (auth.uid() = user_id);

-- 5. Admins can update reviews (for status)
DROP POLICY IF EXISTS "Admins can update reviews" ON public.reviews;
CREATE POLICY "Admins can update reviews" ON public.reviews
    FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM public.profiles
            WHERE profiles.id = auth.uid()
            AND profiles.role = 'admin'
        )
    );

-- 6. Users can delete their own reviews (optional, but good for cleanup)
DROP POLICY IF EXISTS "Users can delete their own reviews" ON public.reviews;
CREATE POLICY "Users can delete their own reviews" ON public.reviews
    FOR DELETE
    USING (auth.uid() = user_id);


-- Function to get average rating (Security Definer to access all ratings regardless of RLS)
CREATE OR REPLACE FUNCTION public.get_product_average_rating(p_id bigint)
RETURNS numeric
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN (SELECT COALESCE(AVG(rating), 0) FROM public.reviews WHERE product_id = p_id);
END;
$$;

-- Function to get review count (Security Definer)
CREATE OR REPLACE FUNCTION public.get_product_review_count(p_id bigint)
RETURNS integer
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN (SELECT COUNT(*) FROM public.reviews WHERE product_id = p_id);
END;
$$;

-- Grant permissions
GRANT SELECT, INSERT, UPDATE, DELETE ON public.reviews TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION public.get_product_average_rating TO anon, authenticated, service_role;
GRANT EXECUTE ON FUNCTION public.get_product_review_count TO anon, authenticated, service_role;

-- Insert sample reviews (if matching order items are found) for testing
-- This attempts to find valid order items from 'shipped' orders and creates approved reviews for them.
INSERT INTO public.reviews (user_id, product_id, order_id, rating, comment, status)
SELECT 
    oi.user_id, 
    oi.product_id, 
    oi.order_id, 
    5, 
    'Sample review: Excellent product!', 
    'approved'
FROM public.order_items oi
JOIN public.orders o ON o.id = oi.order_id
WHERE o.status = 'shipped'
AND NOT EXISTS (
    SELECT 1 FROM public.reviews r 
    WHERE r.order_id = oi.order_id AND r.product_id = oi.product_id
)
LIMIT 3;
